# -*- coding: utf-8 -*-
"""
Created on Fri Jul 14 08:40:05 2023

@author: 1josh

This script is used to collect all data from the HPCC for the high-fidelity calculations which will be used to create our simple emulator.
"""
import numpy as np
import sys, os
import pandas as pd

# Returns dimensions of list of lists
def dim(a):
    if not type(a) == list:
        return []
    return [len(a)] + dim(a[0])

def count_directories(directory):
    count = 0
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        if os.path.isdir(item_path):
            count += 1
    return count

# For reading and formatting data
def read_data(fileName_):
    '''
    given a file name, reads the file line-by-line saving each line as a string. List of strings contains all lines in file with each line being one element in the list.

    Returns list of lines.
    '''
    lines = []
    # Read data in (store each line as list called "lines")
    with open(fileName_) as fp:
        while True:
            line = fp.readline()
            
            lines.append(line)
            if not line: # End when at end of file (no more lines)
                break
    
    return lines

class processGSM_V2:
    '''
    Taken from Josh's code
    
    The purpose of this class is to have all useful tools for processing data generated by Gamow Shell Model (GSM) code in one place. A list of available functions are provided below (details given in each function):

     - getFiles(): given a file path, collects all files based on desired characters and places them inside a pandas DataFrame.

     - getStateInfo(): given a file (can be from getFiles()), finds the energy and |H.PSI-E.PSI| for each found state
    '''

    def __init__(self):
        self.myFiles = []
        self.dataInfo = pd.DataFrame()

    def getFiles(self,path_,stripChars_=[],replaceChars_=[],splitChars_=[],filterChars_=['']):
        '''
        Get all files in a specified path. Returns all path+file names and additional ID markers which can be specified below:
         - stripChars: list of strings which you would like removed for additional ID purposes
         - replaceChars: list of characters you would like to replace for additional ID purposes. Include the character you'd like to remove with the following list item being the character you'd like to replace it with.
         - splitChars: list of characters you would like to subdivide the file name for additional ID purposes
        
        Example:
            path + file  = '~/testFlow/V0_L1-40o0_5He_3I2-_2020.out'
            stripChars   = ['V0_L1-','_2020.out']
            replaceChars = ['o','.','I','/']
            splitChars   = ['_']
            filterChars  = '.out'

            This will operate on the file 'V0_L1-40o0_5He_3I2-_2020.out' to produce:
             prelim. filter ->  Checks if file name contains '.out'
             1. strip       -> '40o0_5He_3I2-'
             2. replace     -> '40.0_5He_3/2-'
             3. split       -> ['40.0','5He','3/2-']
            The total appended list will be [path+file,'40.0','5He','3/2-'].
        '''
        tempInfo = []
        for root, dirs, files in os.walk(path_):
            for file in files:
                if any([True for ch in filterChars_ if ch not in file]):
                    continue

                temp = file
                if stripChars_: # Checks if list is empty (will pass if list is empty)
                    for r in stripChars_:
                        temp = temp.replace(r,'')
                
                if replaceChars_:# Checks if list is empty (will pass if list is empty)
                    for i in range(0,len(replaceChars_),2):
                        temp = temp.replace(replaceChars_[i],replaceChars_[i+1])
                
                if splitChars_:# Checks if list is empty (will pass if list is empty)
                    for r in splitChars_:
                        temp = temp.split(r)
                
                
                tempFile = os.path.join(root,file) # Combines path and file name to one string
                tempFile = tempFile.replace('\\','/')
                
                # If we had any special characters, we will append the items onto the path list
                if any([stripChars_,replaceChars_,splitChars_]):
                    tempInfo.append([tempFile]+temp)
                else: # If no items, just retain path
                    tempInfo.append(tempFile)

        tempInfo.sort(key=lambda tempInfo: tempInfo[0])
        # If we are trying to strip/replace any info from the file name, we'll want to ensure we only save the actual file path from our list (which is actually a list of lists)
        if any(isinstance(el, list) for el in tempInfo):
            self.myFiles = [t[0] for t in tempInfo]
        else: # Otherwise, we simply have a list with only the file path info
            self.myFiles = tempInfo
        self.dataInfo['File Names'] = tempInfo

    def orderExcitation(self,Jlist,J):
        '''Given a list of J's, determine if the J given is in Jlist.
        If it is in the list, increase the excitation underscore e.g.
        Jlist = [0+, 2+, 1+] and J=1+ we should return Jlist=[0+, 2+, 1+,1+_1]'''
        
        # Count the number of times J appears in the list so far
        count = sum([1 for myj in Jlist if J in myj])
        
        newJ = J+'_'+str(count)

        return newJ
        
    def getStateInfo(self):
        '''
        After using function 'getFiles()', will get information for Complex Energy (E-i\Gamma/2) in MeV and |H.PSI-E.PSI| for each J found in the output files. Will append this data to self.dataInfo so parsed values can be found in the same row as the file name.
        '''
        if not self.myFiles: # If empty file info, stop function
            sys.exit('No files given to read. Please use getFiles() to provide a file list to read from.')
        
        # Loop through all found files
        for i, f in enumerate(self.myFiles):
            # Skip iteration if given file is empty
            if os.stat(f).st_size == 0:
                print('Empty file in: ',f)
                continue

            # Get list of strings with each string being one line
            fLines = read_data(f)

            # Set lists for each complex energy found, its stability, and its J value
            E, HPSI, J = [], [], []

            # Boolean for finding section we're interested in
            foundExpectation = False
            for line in fLines:
                # End search if MPI error is detected
                if 'MPI process' in line:
                    print('Found MPI Error: ',line)
                    break

                # Once we get to the summary of the converged results, set our boolean
                # to true to start searching for our desired quantities
                if 'Expectation values' in line:
                    foundExpectation = True
                    continue
                # elif ('Configuration' in line or 'Spectrum' in line) and foundExpectation:
                #     foundExpectation = False
                #     continue

                if foundExpectation:
                    # Get |H.PSI - E.PSI| from line in section
                    if '|H.PSI - E.PSI|' in line:
                        # Eliminate extra characters
                        temp = line.replace('|H.PSI - E.PSI|oo = ','')
                        temp = temp.replace('\n','')

                        # Convert remaining number to float
                        HPSI.append(float(temp))
                    # Find energy section
                    elif 'E:' in line:
                        # Delimiter to distinguish E from J in same line
                        temp = line.replace('J Pi:',',')
                        
                        # List of characters to remove from our line
                        dropChars = ['E:(',')',' ','\n']
                        for j in dropChars:
                            temp = temp.replace(j,'')
                        
                        # Split our line based on Re(E), Im(E), and J Pi
                        tempList = temp.split(',')

                        # Save complex energy
                        E.append(float(tempList[0])+ float(tempList[1])*1j)
                            
                        # Save J Pi value
                        jval = self.orderExcitation(J,tempList[2])
                        J.append(jval)

                        # Reset boolean to continue search for next state (if available)
                        foundExpectation = False
            
            if J: # Only do if J is not empty, i.e. we found a state in the output file
                for iJ, j in enumerate(J):
                    eName = 'E('+j+') MeV'
                    hPsiName = 'HPSI '+j

                    self.dataInfo.loc[i,eName] = E[iJ]
                    self.dataInfo.loc[i,hPsiName] = HPSI[iJ]

def toEandGamma(eTilde):
    # Returns Energy and Gamma given a complex energy \tilde{E}
    return np.real(eTilde), -2*np.imag(eTilde)


#%% 

originalDir = os.getcwd() # Get main directory this code runs in
emuFolder = 'emulator-runs' # Folder to save the emulation data
emulatorDir = os.path.join(originalDir,emuFolder) # Identify emulation folder path

# Get all subdirectories of our emulator folder, each directory is the index
# number for a theta parameter set, i.e. theta_index
nSamples = count_directories(emulatorDir) # Get the total number of dirs (should be equal to sample number!)

results = []
for idir in range(nSamples):
    gsm = processGSM_V2() # create instance to get our GSM data
    # Set path based on emulatorDir location + current theta_index folder
    path = os.path.join(emulatorDir, str(idir).zfill(6))
    # Get all output files found in path
    gsm.getFiles(path,filterChars_=['output'])
    # Scrape all E and HPsi Data
    gsm.getStateInfo()
    
    # Get a list of all energy columns in DataFrame
    enegCols = [col for col in gsm.dataInfo.columns if 'E' in col]
    
    # Get directory names to find nucleus name
    dirNames = gsm.dataInfo['File Names'].to_list()

    # We want to keep track of our energies and their corresponding nucleus
    # and J pi value, so we introduce nucState to build a list which will
    # eventually become the headers for the modelVals csv file.
    nucState = []
    # Append directory name to each energy so that we have an energy for each nucleus
    # note many of these might be blank in the csv as 5He only has 3/2- so any column
    # with J^Pi=0+ for example will return NaN or blank values
    
    # Sometimes there's a weird character thing in the file paths with '\\' or '/'
    # so this is to make everything consistent by just getting rid of it
    noSlashPath = path.replace('\\','')
    noSlashPath = noSlashPath.replace('/','')
    for dn in dirNames:
        dn = dn.replace('\\','')
        dn = dn.replace('/','')
        for ec in enegCols:
            nucState.append(dn+ec)

    # Strip extra characters from the directory name and file name to match the expected formats
    removeChars = [noSlashPath,'output_','_Mao2020.dat','E',' MeV']
    for rc in removeChars:
        nucState = [c.replace(rc,'') for c in nucState]

    # Get our energy datasets as a long numpy array
    npEnegData = gsm.dataInfo[enegCols].to_numpy().flatten()
    eneg, gamma = toEandGamma(npEnegData)
    # Find the results which have Nan and set their \Gammas to be NaN too
    nanIndex = np.isnan(eneg)
    gamma[nanIndex] = np.nan
    
    # Save nucleus and state names with prefixes E and G so we know energy and decay widths
    nucStateE = np.char.add('E', np.array(nucState))
    nucStateG = np.char.add('G', np.array(nucState))
    modelOutNames = list(np.vstack((nucStateE, nucStateG)).T.flatten())
    # Save model outputs to be in the same format as our yMeans
    # modelOutVals = np.array([E_0,Gamma_0,E_1,Gamma_1,...,E_n,Gamma_n])
    modelOutVals = np.vstack((eneg, gamma)).T.flatten()
    # Convert modelOutVals data from MeV to keV
    modelOutVals = 1000 * modelOutVals
    
    # Convert modelOutNames and modelOutVals to a dictionary {modelOutNames:modelOutVals}
    results.append(dict(zip(modelOutNames,modelOutVals)))
    
# Convert results to dataFrame to save as csv
outResults = pd.DataFrame(results)
outResults.to_csv(os.path.join(emulatorDir,"summary_model_vals.csv"),index=False)

print('Found Results:')
print(outResults)
print('saved to csv called summary_model_vals.csv')





