import numpy as np
import scipy.stats as sps
import sys, os
import shutil
import subprocess
import pandas as pd

import time

# Returns dimensions of list of lists
def dim(a):
    if not type(a) == list:
        return []
    return [len(a)] + dim(a[0])

# For reading and formatting data
def read_data(fileName_):
    '''
    given a file name, reads the file line-by-line saving each line as a string. List of strings contains all lines in file with each line being one element in the list.

    Returns list of lines.
    '''
    lines = []
    # Read data in (store each line as list called "lines")
    with open(fileName_) as fp:
        while True:
            line = fp.readline()
            
            lines.append(line)
            if not line: # End when at end of file (no more lines)
                break
    
    return lines

class processGSM_V2:
    '''
    Taken from Josh's code
    
    The purpose of this class is to have all useful tools for processing data generated by Gamow Shell Model (GSM) code in one place. A list of available functions are provided below (details given in each function):

     - getFiles(): given a file path, collects all files based on desired characters and places them inside a pandas DataFrame.

     - getStateInfo(): given a file (can be from getFiles()), finds the energy and |H.PSI-E.PSI| for each found state
    '''

    def __init__(self):
        self.myFiles = []

    def getFiles(self,path_,stripChars_=[],replaceChars_=[],splitChars_=[],filterChars_=['']):
        '''
        Get all files in a specified path. Returns all path+file names and additional ID markers which can be specified below:
         - stripChars: list of strings which you would like removed for additional ID purposes
         - replaceChars: list of characters you would like to replace for additional ID purposes. Include the character you'd like to remove with the following list item being the character you'd like to replace it with.
         - splitChars: list of characters you would like to subdivide the file name for additional ID purposes
        
        Example:
            path + file  = '~/testFlow/V0_L1-40o0_5He_3I2-_2020.out'
            stripChars   = ['V0_L1-','_2020.out']
            replaceChars = ['o','.','I','/']
            splitChars   = ['_']
            filterChars  = '.out'

            This will operate on the file 'V0_L1-40o0_5He_3I2-_2020.out' to produce:
             prelim. filter ->  Checks if file name contains '.out'
             1. strip       -> '40o0_5He_3I2-'
             2. replace     -> '40.0_5He_3/2-'
             3. split       -> ['40.0','5He','3/2-']
            The total appended list will be [path+file,'40.0','5He','3/2-'].
        '''
        tempInfo = []
        for root, dirs, files in os.walk(path_):
            for file in files:
                if any([True for ch in filterChars_ if ch not in file]):
                    continue

                temp = file
                if stripChars_: # Checks if list is empty (will pass if list is empty)
                    for r in stripChars_:
                        temp = temp.replace(r,'')
                
                if replaceChars_:# Checks if list is empty (will pass if list is empty)
                    for i in range(0,len(replaceChars_),2):
                        temp = temp.replace(replaceChars_[i],replaceChars_[i+1])
                
                if splitChars_:# Checks if list is empty (will pass if list is empty)
                    for r in splitChars_:
                        temp = temp.split(r)
                
                # tempInfo.append(temp)
                # tempFiles.append(os.path.join(root,file))
                tempFile = os.path.join(root,file) # Combines path and file name to one string
                tempFile = tempFile.replace('\\','/')
                
                # If we had any special characters, we will append the items onto the path list
                if any([stripChars_,replaceChars_,splitChars_]):
                    tempInfo.append([tempFile]+temp)
                else: # If no items, just retain path
                    tempInfo.append(tempFile)

        tempInfo.sort(key=lambda tempInfo: tempInfo[0])
        # If we are trying to strip/replace any info from the file name, we'll want to ensure we only save the actual file path from our list (which is actually a list of lists)
        if any(isinstance(el, list) for el in tempInfo):
            self.myFiles = [t[0] for t in tempInfo]
        else: # Otherwise, we simply have a list with only the file path info
            self.myFiles = tempInfo
        self.dataInfo = pd.DataFrame(tempInfo)

    def getStateInfo(self):
        '''
        After using function 'getFiles()', will get information for Complex Energy (E-i\Gamma/2) in MeV and |H.PSI-E.PSI| for each J found in the output files. Will append this data to self.dataInfo so parsed values can be found in the same row as the file name.
        '''
        if not self.myFiles: # If empty file info
            sys.exit('No files given to read. Please use getFiles() to provide a file list to read from.')
    #     lines = read_data(fileName_)
        for i, f in enumerate(self.myFiles):
            # Terminate if given file is empty
            if os.stat(f).st_size == 0:
                print('Empty file in: ',f)
                continue

            fLines = read_data(f)

            # E, G, HPSI, J = [], [], [], []
            E, HPSI, J = [], [], []
            foundExpectation = False
            for line in fLines:
                if 'MPI process' in line:
                    print('Found MPI Error: ',line)
                    break

                if 'Expectation values' in line:
                    foundExpectation = True
                    continue
                elif ('Configuration' in line or 'Spectrum' in line) and foundExpectation:
                    foundExpectation = False
                    continue

                if foundExpectation:
                    # Get |H.PSI - E.PSI| from line in section
                    if '|H.PSI - E.PSI|' in line:
                        temp = line.replace('|H.PSI - E.PSI|oo = ','')
                        temp = temp.replace('\n','')
                        HPSI.append(float(temp))
                    elif 'E:' in line:
                        temp = line.replace('J Pi:',',')
                        
                        dropChars = ['E:(',')',' ','\n']
                        for j in dropChars:
                            temp = temp.replace(j,'')
                        
                        tempList = temp.split(',')
                        E.append(float(tempList[0])+ float(tempList[1])*1j)
                        # G.append(float(tempList[1])*-2)
                        J.append(tempList[2])
            
            if J: # Only do if J is not empty
                for iJ, j in enumerate(J):
                    eName = 'E('+j+') MeV'
                    hPsiName = 'HPSI '+j

                    self.dataInfo.loc[i,eName] = E[iJ]
                    self.dataInfo.loc[i,hPsiName] = HPSI[iJ]

def toEandGamma(eTilde):
    # Returns Energy and Gamma given a complex energy \tilde{E}
    return np.real(eTilde), -2*np.imag(eTilde)

def setup_gsm(theta,dirForWorkspace):
    os.mkdir(dirForWorkspace)
    os.mkdir(os.path.join(dirForWorkspace,'workspace'))
    for i in range(gsmNodes):
        os.mkdir(os.path.join(dirForWorkspace,'workspace','node_'+str(i)))
    
    # Names of all template files you wish to use
    templateNames = ['template_5He_Mao2020.temp','template_5Li_Mao2020.temp',
                     'template_6Be_Mao2020.temp','template_6He_Mao2020.temp',
                     'template_6Li_Mao2020.temp']

    # For all our input files given theta, set the proper parameters
    replaceDict = {"$GSM_NODES":gsmNodes, "$GSM_CPUS":gsmCPUs,
                    "$L1_dn":theta[0], "$L1_r0n":theta[1],
                    "$L1_v0n":theta[2], "$L1_vson":theta[3],
                    "$L1_dp":theta[4], "$L1_r0p":theta[5],
                    "$L1_v0p":theta[6], "$L1_vsop":theta[7],
                    "$Vc10":theta[8], "$Vc00":theta[9],
                    "$Vc01":theta[10], "$Vt10":theta[11]}
    
    # Create an empty list to put our input file names into as we make them
    inputNameList = []
    # Define path to get to template directory
    templateDir = os.path.join(originalDir,'templates')
    
    # Loop through all templates in our templateNames list
    for tempName in templateNames:
        # Open our template and read each line into a list
        with open(os.path.join(templateDir,tempName)) as temp:
            fileTemplate = temp.readlines()
        
        # Create input file name by generic process template_5He_Mao2020
        inputName = tempName.replace('template','input')
        inputName = inputName.replace('.temp','.dat')
        inputNameList.append(inputName)
        
        # Open our input file as write
        with open(os.path.join(dirForWorkspace,inputName),'w') as f:
            # Loop through each input template line
            for line in fileTemplate:
                # loop through each dictionary item name 'key'
                for key, value in replaceDict.items():
                    # Replace the current dictionary item with its value
                    line = line.replace(key, str(value))
                f.write(line)
    return inputNameList

def run_gsm(di,inputNames):
    shutil.copy('GSM_exe',di)
    os.chdir(di)
    for inName in inputNames:
        partStart = time.time()
        outName = inName.replace('input','output')
        subprocess.run('mpirun -np {} -map-by node -bind-to none ./GSM_exe <{} > {}'.format(gsmNodes,inName,outName),
                       shell=True)
        
        partEnd = time.time()
        print(inName," runtime = ",partEnd - partStart)
    os.chdir(originalDir)
    os.remove(os.path.join(di,'GSM_exe'))
    return None
    
def model(x,params,templateNames_):
    """
    x is a dummy argument b/c surmise expects it. If we were to calibrate to multiple
    nuclei, x might be (N,Z). Not quite - surmise can get by on a 1D array (I'm not
    sure how it handles D-dimensional data). So, Kyle and friends use it as an index
    for the observations
    """
    modelOut = np.zeros((params.shape[0],6))
    
    currentDirs = sorted(os.listdir('test-runs'))
    newIter = len(currentDirs)+1
    di = os.path.join('test-runs',str(newIter).zfill(6))
    
    inputNames = setup_gsm(params,di,templateNames_)
    run_gsm(di,inputNames)
    
    gsm = processGSM_V2()

    gsm.getFiles(di,filterChars_=['output.dat'])
    gsm.getStateInfo()
    eneg, gamma = toEandGamma(gsm.dataInfo['E(3/2-) MeV'])
    modelOut[0,0] = eneg
    modelOut[0,2] = eneg
    modelOut[0,4] = eneg
    
    modelOut[0,1] = gamma
    modelOut[0,3] = gamma
    modelOut[0,5] = gamma
    
    return 1000*modelOut

start = time.time()

#From Mao's paper
#neutron case (5He)
paramMeans = np.array([0.63,2.15,39.5,10.7,
                       0.64,2.06,42.1,11.1,
                       -8.309,-8.895,-9.425,-22.418])

# paramStds = np.array([0.02,0.04,0.2,0.2])

gsmNodes = 3
gsmCPUs = 3

originalDir = os.getcwd()

data = model([],paramMeans)

end = time.time()
print("Total runtime = ",end - start)

# nSamples = 100
# thetaTest = Prior.rnd(nSamples)
# modelVals = model([],thetaTest)

#From NNDC (bug Josh about it, but it's S_n and NNDC Gamma error)
# yMean = np.array([735.,600,735.,600,735.,600])
# yStd = np.array([20.,20,20,20,20,20])

# xTest = np.asarray([1,2,3,4,5,6])
# xTest = np.arange(len(yMean)) #I don't really know what this does
# emu = emulator(x=xTest,theta=thetaTest,f=modelVals,method='PCGP')

# #%%
# cal = calibrator(emu=emu,
#                  y=yMean,
#                  thetaprior=Prior,
#                  yvar=yStd,
#                  method='directbayes',
#                  args={'theta0':paramMeans.reshape((1,-1)),
#                        'sampler':'metropolis_hastings',
#                        'numsamp':50000,
#                        'burnSamples':2000,
#                        'stepType':'normal'})

# #%%
# fig = corner.corner(cal.info['thetarnd'],
#                     labels=["L1_d","L1_r0","L1_v0","L1_vso"])

# axArr = np.array(fig.axes).reshape((4,4))
# for (i,theta) in enumerate(paramMeans):
#     axArr[i,i].axvline(theta,color='red')
#     axArr[i,i].axvspan(theta-paramStds[i],theta+paramStds[i],color='red',alpha=0.2)
    
#     axArr[i,0].set(xlim=(0.5,0.7))

