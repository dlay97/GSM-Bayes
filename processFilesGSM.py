import pandas as pd
import numpy as np
import os
import sys

# I'll need to make something which reads files given a path.
    # possibly recursive to search through all files in a path with given file structure?
    # store as self.files list
# Optional natural orbital reference files can be found with same process as above.
    # Store as self.natOrbFiles list
# Iterating through self.files list, use individual functions which return arrays of
    # J^pi many-body state, its |H.PSI-E.PSI|, E and G (MeV)
    # Spectroscopic Factors
    # (Basis) Potential for a given \ell
    # Contour components for a given partial wave

# Returns dimensions of list of lists
def dim(a):
    if not type(a) == list:
        return []
    return [len(a)] + dim(a[0])

# For reading and formatting data
def read_data(fileName_):
    '''
    given a file name, reads the file line-by-line saving each line as a string. List of strings contains all lines in file with each line being one element in the list.

    Returns list of lines.
    '''
    lines = []
    # Read data in (store each line as list called "lines")
    with open(fileName_) as fp:
        while True:
            line = fp.readline()
            
            lines.append(line)
            if not line: # End when at end of file (no more lines)
                break
    
    return lines

class processGSM_V2:
    '''
    The purpose of this class is to have all useful tools for processing data generated by Gamow Shell Model (GSM) code in one place. A list of available functions are provided below (details given in each function):

     - getFiles(): given a file path, collects all files and places them inside a pandas DataFrame.

     - getStateInfo():

     - getSFs():

     - getProjInfo():
    '''

    def __init__(self):
        self.myFiles = []

    def getFiles(self,path_,stripChars_=[],replaceChars_=[],splitChars_=[],filterChars_=['']):
        '''
        Get all files in a specified path. Returns all path+file names and additional ID markers which can be specified below:
         - stripChars: list of strings which you would like removed for additional ID purposes
         - replaceChars: list of characters you would like to replace for additional ID purposes. Include the character you'd like to remove with the following list item being the character you'd like to replace it with.
         - splitChars: list of characters you would like to subdivide the file name for additional ID purposes
        
        Example:
            path + file  = '~/testFlow/V0_L1-40o0_5He_3I2-_2020.out'
            stripChars   = ['V0_L1-','_2020.out']
            replaceChars = ['o','.','I','/']
            splitChars   = ['_']
            filterChars  = '.out'

            This will operate on the file 'V0_L1-40o0_5He_3I2-_2020.out' to produce:
             prelim. filter ->  Checks if file name contains '.out'
             1. strip       -> '40o0_5He_3I2-'
             2. replace     -> '40.0_5He_3/2-'
             3. split       -> ['40.0','5He','3/2-']
            The total appended list will be [path+file,'40.0','5He','3/2-'].
        '''
        tempInfo = []
        for root, dirs, files in os.walk(path_):
            for file in files:
                if any([True for ch in filterChars_ if ch not in file]):
                    continue

                temp = file
                if stripChars_: # Checks if list is empty (will pass if list is empty)
                    for r in stripChars_:
                        temp = temp.replace(r,'')
                
                if replaceChars_:# Checks if list is empty (will pass if list is empty)
                    for i in range(0,len(replaceChars_),2):
                        temp = temp.replace(replaceChars_[i],replaceChars_[i+1])
                
                if splitChars_:# Checks if list is empty (will pass if list is empty)
                    for r in splitChars_:
                        temp = temp.split(r)
                
                # tempInfo.append(temp)
                # tempFiles.append(os.path.join(root,file))
                tempFile = os.path.join(root,file) # Combines path and file name to one string
                tempFile = tempFile.replace('\\','/')
                # print(tempFile,file)
                # If we had any special characters, we will append the items onto the path list
                if any([stripChars_,replaceChars_,splitChars_]):
                    tempInfo.append([tempFile]+temp)
                else: # If no items, just retain path
                    tempInfo.append(tempFile)

        tempInfo.sort(key=lambda tempInfo: tempInfo[0])
        # If we are trying to strip/replace any info from the file name, we'll want to ensure we only save the actual file path from our list (which is actually a list of lists)
        if any(isinstance(el, list) for el in tempInfo):
            self.myFiles = [t[0] for t in tempInfo]
        else: # Otherwise, we simply have a list with only the file path info
            self.myFiles = tempInfo
        self.dataInfo = pd.DataFrame(tempInfo)

    def getStateInfo(self):
        '''
        After using function 'getFiles()', will get information for Complex Energy (E-i\Gamma/2) in MeV and |H.PSI-E.PSI| for each J found in the output files. Will append this data to self.dataInfo so parsed values can be found in the same row as the file name.
        '''
        if not self.myFiles: # If empty file info
            sys.exit('No files given to read. Please use getFiles() to provide a file list to read from.')
    #     lines = read_data(fileName_)
        for i, f in enumerate(self.myFiles):
            # Terminate if given file is empty
            if os.stat(f).st_size == 0:
                print('Empty file in: ',f)
                continue

            fLines = read_data(f)

            # E, G, HPSI, J = [], [], [], []
            E, HPSI, J = [], [], []
            foundExpectation = False
            for line in fLines:
                if 'MPI process' in line:
                    print('Found MPI Error: ',line)
                    break

                if 'Expectation values' in line:
                    foundExpectation = True
                    continue
                elif ('Configuration' in line or 'Spectrum' in line) and foundExpectation:
                    foundExpectation = False
                    continue

                if foundExpectation:
                    # Get |H.PSI - E.PSI| from line in section
                    if '|H.PSI - E.PSI|' in line:
                        temp = line.replace('|H.PSI - E.PSI|oo = ','')
                        temp = temp.replace('\n','')
                        HPSI.append(float(temp))
                    elif 'E:' in line:
                        temp = line.replace('J Pi:',',')
                        
                        dropChars = ['E:(',')',' ','\n']
                        for j in dropChars:
                            temp = temp.replace(j,'')
                        
                        tempList = temp.split(',')
                        E.append(float(tempList[0])+ float(tempList[1])*1j)
                        # G.append(float(tempList[1])*-2)
                        J.append(tempList[2])
            
            if J: # Only do if J is not empty
                for iJ, j in enumerate(J):
                    eName = 'E('+j+') MeV'
                    hPsiName = 'HPSI '+j

                    self.dataInfo.loc[i,eName] = E[iJ]
                    self.dataInfo.loc[i,hPsiName] = HPSI[iJ]