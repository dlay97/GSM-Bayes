import surmise
from surmise.emulation import emulator
from surmise.calibration import calibrator

import numpy as np
import scipy.stats as sps
import sys, os
import shutil
import subprocess
import pandas as pd

import corner

# Returns dimensions of list of lists
def dim(a):
    if not type(a) == list:
        return []
    return [len(a)] + dim(a[0])

# For reading and formatting data
def read_data(fileName_):
    '''
    given a file name, reads the file line-by-line saving each line as a string. List of strings contains all lines in file with each line being one element in the list.

    Returns list of lines.
    '''
    lines = []
    # Read data in (store each line as list called "lines")
    with open(fileName_) as fp:
        while True:
            line = fp.readline()
            
            lines.append(line)
            if not line: # End when at end of file (no more lines)
                break
    
    return lines

class processGSM_V2:
    '''
    Taken from Josh's code
    
    The purpose of this class is to have all useful tools for processing data generated by Gamow Shell Model (GSM) code in one place. A list of available functions are provided below (details given in each function):

     - getFiles(): given a file path, collects all files and places them inside a pandas DataFrame.

     - getStateInfo():

     - getSFs():

     - getProjInfo():
    '''

    def __init__(self):
        self.myFiles = []

    def getFiles(self,path_,stripChars_=[],replaceChars_=[],splitChars_=[],filterChars_=['']):
        '''
        Get all files in a specified path. Returns all path+file names and additional ID markers which can be specified below:
         - stripChars: list of strings which you would like removed for additional ID purposes
         - replaceChars: list of characters you would like to replace for additional ID purposes. Include the character you'd like to remove with the following list item being the character you'd like to replace it with.
         - splitChars: list of characters you would like to subdivide the file name for additional ID purposes
        
        Example:
            path + file  = '~/testFlow/V0_L1-40o0_5He_3I2-_2020.out'
            stripChars   = ['V0_L1-','_2020.out']
            replaceChars = ['o','.','I','/']
            splitChars   = ['_']
            filterChars  = '.out'

            This will operate on the file 'V0_L1-40o0_5He_3I2-_2020.out' to produce:
             prelim. filter ->  Checks if file name contains '.out'
             1. strip       -> '40o0_5He_3I2-'
             2. replace     -> '40.0_5He_3/2-'
             3. split       -> ['40.0','5He','3/2-']
            The total appended list will be [path+file,'40.0','5He','3/2-'].
        '''
        tempInfo = []
        for root, dirs, files in os.walk(path_):
            for file in files:
                if any([True for ch in filterChars_ if ch not in file]):
                    continue

                temp = file
                if stripChars_: # Checks if list is empty (will pass if list is empty)
                    for r in stripChars_:
                        temp = temp.replace(r,'')
                
                if replaceChars_:# Checks if list is empty (will pass if list is empty)
                    for i in range(0,len(replaceChars_),2):
                        temp = temp.replace(replaceChars_[i],replaceChars_[i+1])
                
                if splitChars_:# Checks if list is empty (will pass if list is empty)
                    for r in splitChars_:
                        temp = temp.split(r)
                
                # tempInfo.append(temp)
                # tempFiles.append(os.path.join(root,file))
                tempFile = os.path.join(root,file) # Combines path and file name to one string
                tempFile = tempFile.replace('\\','/')
                # print(tempFile,file)
                # If we had any special characters, we will append the items onto the path list
                if any([stripChars_,replaceChars_,splitChars_]):
                    tempInfo.append([tempFile]+temp)
                else: # If no items, just retain path
                    tempInfo.append(tempFile)

        tempInfo.sort(key=lambda tempInfo: tempInfo[0])
        # If we are trying to strip/replace any info from the file name, we'll want to ensure we only save the actual file path from our list (which is actually a list of lists)
        if any(isinstance(el, list) for el in tempInfo):
            self.myFiles = [t[0] for t in tempInfo]
        else: # Otherwise, we simply have a list with only the file path info
            self.myFiles = tempInfo
        self.dataInfo = pd.DataFrame(tempInfo)

    def getStateInfo(self):
        '''
        After using function 'getFiles()', will get information for Complex Energy (E-i\Gamma/2) in MeV and |H.PSI-E.PSI| for each J found in the output files. Will append this data to self.dataInfo so parsed values can be found in the same row as the file name.
        '''
        if not self.myFiles: # If empty file info
            sys.exit('No files given to read. Please use getFiles() to provide a file list to read from.')
    #     lines = read_data(fileName_)
        for i, f in enumerate(self.myFiles):
            # Terminate if given file is empty
            if os.stat(f).st_size == 0:
                print('Empty file in: ',f)
                continue

            fLines = read_data(f)

            # E, G, HPSI, J = [], [], [], []
            E, HPSI, J = [], [], []
            foundExpectation = False
            for line in fLines:
                if 'MPI process' in line:
                    print('Found MPI Error: ',line)
                    break

                if 'Expectation values' in line:
                    foundExpectation = True
                    continue
                elif ('Configuration' in line or 'Spectrum' in line) and foundExpectation:
                    foundExpectation = False
                    continue

                if foundExpectation:
                    # Get |H.PSI - E.PSI| from line in section
                    if '|H.PSI - E.PSI|' in line:
                        temp = line.replace('|H.PSI - E.PSI|oo = ','')
                        temp = temp.replace('\n','')
                        HPSI.append(float(temp))
                    elif 'E:' in line:
                        temp = line.replace('J Pi:',',')
                        
                        dropChars = ['E:(',')',' ','\n']
                        for j in dropChars:
                            temp = temp.replace(j,'')
                        
                        tempList = temp.split(',')
                        E.append(float(tempList[0])+ float(tempList[1])*1j)
                        # G.append(float(tempList[1])*-2)
                        J.append(tempList[2])
            
            if J: # Only do if J is not empty
                for iJ, j in enumerate(J):
                    eName = 'E('+j+') MeV'
                    hPsiName = 'HPSI '+j

                    self.dataInfo.loc[i,eName] = E[iJ]
                    self.dataInfo.loc[i,hPsiName] = HPSI[iJ]

def toEandGamma(eTilde):
    # Returns Energy and Gamma given a complex energy \tilde{E}
    return np.real(eTilde), -2*np.imag(eTilde)

class Prior:
    def lpdf(theta):
        ret = np.zeros(theta.shape[0])
        for i in range(len(paramMeans)):
            toAdd = sps.norm.logpdf(theta[:,i],paramMeans[i],paramStds[i])
            ret += toAdd
            
        return ret.reshape((-1,1))
    
    def rnd(n):
        ret = np.zeros((n,len(paramMeans)))
        for i in range(len(paramMeans)):
            ret[:,i] = sps.norm.rvs(loc=paramMeans[i],scale=paramStds[i],
                                    size=n)
        return ret

def setup_gsm(theta,dirForWorkspace):
    os.mkdir(dirForWorkspace)
    os.mkdir(os.path.join(dirForWorkspace,'workspace'))
    for i in range(gsmCPUs):
        os.mkdir(os.path.join(dirForWorkspace,'workspace','node_'+str(i)))
        
    # Open our template and read each line into a list
    with open(templateName) as temp:
        fileTemplate = temp.readlines()
    
    replaceDict = {"$GSM_NODES":gsmNodes, "$GSM_CPUS":gsmCPUs, 
                   "$L1_d":theta[0], "$L1_r0":theta[1],
                   "$L1_v0":theta[2], "$L1_vso":theta[3]}
    # Open our input file as write
    with open(os.path.join(dirForWorkspace,'input.dat'),'w') as f:
        # Loop through each input template line
        for line in fileTemplate:
            # loop through each dictionary item name 'key'
            for key, value in replaceDict.items():
                # Replace the current dictionary item with its value
                line = line.replace(key, str(value))
            f.write(line)
    return None

def run_gsm(di):
    shutil.copy('GSM_exe',di)
    os.chdir(di)
    subprocess.run('mpirun -np 3 -map-by node -bind-to none ./GSM_exe <input.dat >output.dat',
                   shell=True)
    os.chdir(originalDir)
    os.remove(os.path.join(di,'GSM_exe'))
    return None
    
def model(x,params):
    """
    x is a dummy argument b/c surmise expects it. If we were to calibrate to multiple
    nuclei, x might be (N,Z). Not quite - surmise can get by on a 1D array (I'm not
    sure how it handles D-dimensional data). So, Kyle and friends use it as an index
    for the observations
    """
    modelOut = np.zeros((params.shape[0],6))
    
    for (pIter,p) in enumerate(params):
        currentDirs = sorted(os.listdir('model-runs'))
        newIter = len(currentDirs)+1
        di = os.path.join('model-runs',str(newIter).zfill(6))
        
        setup_gsm(p,di)
        run_gsm(di)
        
        gsm = processGSM_V2()
    
        gsm.getFiles(di,filterChars_=['output.dat'])
        gsm.getStateInfo()
        eneg, gamma = toEandGamma(gsm.dataInfo['E(3/2-) MeV'])
        modelOut[pIter,0] = eneg
        modelOut[pIter,2] = eneg
        modelOut[pIter,4] = eneg
        
        modelOut[pIter,1] = gamma
        modelOut[pIter,3] = gamma
        modelOut[pIter,5] = gamma
    
    return 1000*modelOut

#From Mao's paper
#neutron case (5He)
paramMeans = np.array([0.63,2.15,39.5,10.7])
paramStds = np.array([0.02,0.04,0.2,0.2])

gsmNodes = 3
gsmCPUs = 3

templateName = 'template_5He_3I2-Mao2020.temp'

originalDir = os.getcwd()

nSamples = 100
thetaTest = Prior.rnd(nSamples)
modelVals = model([],thetaTest)

#From NNDC (bug Josh about it, but it's S_n and NNDC Gamma error)
yMean = np.array([735.,600,735.,600,735.,600])
yStd = np.array([20.,20,20,20,20,20])

# xTest = np.asarray([1,2,3,4,5,6])
xTest = np.arange(len(yMean)) #I don't really know what this does
emu = emulator(x=xTest,theta=thetaTest,f=modelVals,method='PCGP')

#%%
cal = calibrator(emu=emu,
                 y=yMean,
                 thetaprior=Prior,
                 yvar=yStd,
                 method='directbayes',
                 args={'theta0':paramMeans.reshape((1,-1)),
                       'sampler':'metropolis_hastings',
                       'numsamp':50000,
                       'burnSamples':2000,
                       'stepType':'normal'})

#%%
fig = corner.corner(cal.info['thetarnd'],
                    labels=["L1_d","L1_r0","L1_v0","L1_vso"])

axArr = np.array(fig.axes).reshape((4,4))
for (i,theta) in enumerate(paramMeans):
    axArr[i,i].axvline(theta,color='red')
    axArr[i,i].axvspan(theta-paramStds[i],theta+paramStds[i],color='red',alpha=0.2)
    
    axArr[i,0].set(xlim=(0.5,0.7))

